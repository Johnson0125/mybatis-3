# Java 正则表达式教程
原文链接：[http://www.vogella.com/tutorials/JavaRegularExpressions/article.html](http://www.vogella.com/tutorials/JavaRegularExpressions/article.html)
### Java 和正则表达式
本教程介绍了正则表达式的使用描述了正则表达式在 Java 中的实现。同时，本教程也提供了一些 Java 正则表达式的例子。

## 内容列表
1. 则表达式
    1.1. 什么是正则表达式？
    1.2. 正则表达式例子
    1.3. 编程语言对正则表达式的支持
2. 编写正则表达式的规则
    2.1. 常用的符号匹配
    2.2. 元字符
    2.3. 数量修饰符
    2.4. 分组和后向引用
    2.5. 反向预查
    2.6. 正则表达式内定义模式
    2.7. Java 中的反斜杠
3. 借助于 String 中的方法来使用正则表达式
    3.1. 通过String 中重定义的方法来处理正则表达式
    3.2. 例子
4. Pattern 和 Matcher
5. Java 正则表达式例子
    5.1. 选择（Or）
    5.2. 电话号码
    5.3. 检查一个数字的范围
    5.4. 写一个链接检查器
    5.5. 查找重复的单词
    5.6. 查找以一个新行开始的元素
    5.7. 查找（非 Java 文档）的语句
6. 在 Eclipse 中处理正则表达式

##1. 正则表达式
###1.1. 什么是正则表达式？

一个正则表达式为一个字符串定义了查找模式。regex 是正则表达式的缩写。查找模式是任意的，可以是一个简单的字符，一个确定的字符串或者是一个复杂的表达式，这个表达式包含了特殊的字符来描述这个模式。对一个给定的字符串来说，正则表达式定义的模式可以匹配 0 次或 1 次或多次。

正则表达式可以用来查找、编辑和操作文本。

使用正则表达式分析或者是修改文本的过程叫做：正则表达式应用于文本（字符串）。正则表达式定义的模式从左到右应用于文本。一个源文本中的字符一旦被匹配使用后，该字符不能被再次匹配使用。例如，正则表达式 aba 仅会匹配字符串 ababababa 两次（aba_aba__）。

### 1.2. 正则表达式例子

一个字符串就是正则表达式的一个简单例子。例如， Hello World 这个正则表达式将会匹配 “Hello World” 这个字符串。.（点）是正则表达式的另一个例子。一个点可以匹配任意的单个字符；例如，一个点可以匹配“a”或者是“Z”或者是“1”。

下面的表格中列出了几个正则表达式的例子并且描述了这些正则表达式匹配的模式。

表格 1. 正则表达式例子

Regex                  Matches
this is text           只精确匹配“this is text”
this\s+is\s+text       匹配单词“this”后面紧接着有一个或多个空格字符接着有“is”接着又有一个或多个空格字符接着有单词“text”。
^\d+(\.\d+)?           ^定义了模式必须从一个新行的最开始处处开始匹配。\d+匹配一个或多个数字。?表示括号内的语句为可选的，即匹配括号内的语句 0 次或 1 次。\.匹配“.”，圆括号用于分组。例如，整个正则表达式可以匹配“5”，“1.5”，“2.21”。

### 1.3. 各种编程语言对正则表达式的支持
大部分的编程语言都支持正则表达式，例如：Java ，Perl , Grovy 等。遗憾的是每种语言对正则表达式的支持稍有不同。

## 2. 编写正则表达式的规则
下面的教程假设你已经具备了 Java 编程语言的基础。

下面的一些例子使用了 JUnit 来验证结果。如果你不想使用 JUnit 可以自己调整。可以在[JUnit 教程](http://www.vogella.com/tutorials/JUnit/article.html)中学习 JUnit 的用法。
## 2.1. 常用的符号匹配
 表格 2.
 
 正则表达式   描述
 .          匹配任意单个字符
 ^regex     必须从新行的最开始处匹配正则表达式
 regex$     必须匹配正则表达式到行的末尾。
 [abc]      集合定义（[] 定义了一个集合），可以匹配集合中的任意一个字符，即可以匹配 a 或者 b 或者 c 。
 [abc][vz]  集合定义，可以匹配 a 或 b 或 c 紧接着匹配 v 或 z 。
 [^abc]     当 ^ 在方括号内的最开始处出现时表示对原有的模式进行了否定。该模式匹配除了 a 或 b 或者 c 之外的任意单个字符。
 [a-d1-7]   范围：匹配 a 到 d 之间的任意一个字符和 1 到 7 之间的数字，但不匹配 d1 。       
 X|Z        查找 X 或 Z 。
 XZ         查找 X 后面紧接着 Z 。
 $          检查是否到了行末。 
 
 ## 2.2。 元字符
 下面的元字符都有预定义的含义，比某些常用的模式更容易使用，例如 \d 可以替代 [0-9] 。
 表格 3 。
 正则表达式   描述
 \d         匹配单个数字，等同于 [0-9] 。
 \D         匹配单个非数字字符，等同于 [^0-9] 。
 \s         匹配单个空白字符，等同于 [\t\n\x0b\r\f]
 \S         匹配单个非空白字符，等同于 [^\s]
 \w         匹配单个单词字符，等同于 [a-zA-Z0-9_]
 \W         匹配单个非单词字符，等同于 [^w]
 \s+        匹配 1 个或多个连续的空白字符，等同于
 \b         匹配一个单词的边界，单词是由单词字符组成的，单词字符为 [a-zA-Z0-9_] 。
 提示：这些元字符都是他们所代表的单词的首字母，例如：d 代表 digit，s 代表 space ，w 代表 word，b 代表 boundary，大写字符与原字符的意义相反。
## 2.3. 数量修饰符
数量修饰符定义了一个元素可以出现的次数。

表格 4.
正则表达式    描述                             示例
*           出现 1 次或多次，等同于 {0,}        X* 匹配 0 个或多个 X 字母。
                                            .*  匹配任意字符序列。           
+           出现 1 次或多次，等同于 {1,}          X+ 匹配一个 X 字符或多个 X 字符。          
?           不出现或只出现 1 次，等同于 {0,1}   X? X 字符不出现或 X 字符只出现一次。
{X}         出现 X 次，{} 描述了一个范围       \d{3} 匹配 3 个字符，.{10} 匹配长度为 10 的任意字符序列。
{X,Y}       出现次数位于 X 与 Y 之间。          \d{1,4} 表示至少有 1 位数字至多有 4 位数字。
*?          ? 出现在数量修饰符后有特殊含义，正则表达式会尝试最小匹配
            最小匹配会要求正则表达式在初次满足匹配条件以后就停止。

## 2.4. 分组和后向引用
可以给正则表达式分组。在正则表达式定义的模式中，可以通过使用圆括号把元素扩起来进行分组。分组会对各个组元素分配一个操作符，可以通过这个操作符来重复引用相应的组元素。

后向引用保存了与相应匹配组匹配的字符串，这些字符串是待匹配文本的一个子串。这样一来，我们可以对待匹配文本中的这些子串进行替换操作。

通过 $ 符号可以引用分组，$1 代表第一个分组，$2 代表第二个分组，以此类推。

假如，我们想要去掉一个字母和 . 或 , 之间的所有空格。这就要求 . 和 , 是模式的一部分。而且，. 或 , 最终要保留为结果的一部分。

```
String test = "a    \n   .";
String pattern = "(\\w)(\\s+)([\\.,])";
System.out.println(test.replaceAll(pattern, "$1$3"));
// 还可以拼接自己想要的字符串
System.out.println(test.replaceAll(pattern, "hello,$1,world,$3,end"));
```

控制台输出结果：

```
a.
hello,a,world,.,end
```

提取标签文本值的一个例子：

```
// 剧透一下，(?i) 表示不区分大小写，其后的模式匹配再不区分大小写
// 注意 (?i) 不是分组，pattern = "(?i)(<title.*?>)(.+?)(</title>)" 有三个分组分别是:(<title.*?>)、(.+?)、(</title>)
String pattern = "(?i)(<title.*?>)(.+?)(</title>)";
System.out.println(<title>hello, world</title>".replaceAll(pattern, "$2"));    
System.out.println(<TITLE>HELLO, world</TItle>".replaceAll(pattern, "$2"));   

```

控制台输出：
```
hello, world
HELLO, world
```

## 2.5. 否定预查
否定预查为排除模式提供了可能。通过否定可以表达出一个字符串后面不能跟着另外一个字符串这种模式。否定预查可以通过 (?!pattern) 这种方式来定义。例如，下面的例子中如果“a”后面不跟着“b”的话就会匹配“a”。

```
a(?!b)
```














      
                            
 
 




    
